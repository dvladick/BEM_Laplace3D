import numpy as np
import vedo as vd


def legendre_gauss_quadrature(deg):
    """
    Returns points and weights for 2D gaussian quadrature on a square domain [0, 1] x [0, 1].
    :param deg: int
    Number of points for single dimension.
    :return: array_like
    t_gauss, v_gauss - points coordinates of 2D gaussian quadrature.
    weights - weights of 2D gaussian quadrature.
    """

    x, w = np.polynomial.legendre.leggauss(deg)
    gauss_pts = np.array(np.meshgrid(x, x, indexing='ij')).reshape(2, -1).T
    t_gauss = (gauss_pts[:, 0] + 1) / 2
    v_gauss = (gauss_pts[:, 1] + 1) / 2
    weights = (w * w[:, None]).ravel() / 4

    return t_gauss, v_gauss, weights


def intersect_uniform_mesh(path, shift, scale, x_min, x_max, y_min, y_max, resolution, z_step):
    """
    A function that defines an unstructured triangular mesh limited by
    a cut of the geometry specified by the stl file by a plane perpendicular to the z-axis.
    :param path: string
    The path to the stl file.
    :param shift: tuple
    A tuple of three real numbers defining a shift in three directions along the x, y and z axes.
    :param scale: tuple
    A tuple of three real numbers defining a scale in three directions along the x, y and z axes.
    :param x_min: float
    The minimum value along the x-axis that bounds the final 2D mesh area.
    :param x_max: float
    The maximum value along the x-axis that bounds the final 2D mesh area.
    :param y_min: float
    The minimum value along the y-axis that bounds the final 2D mesh area.
    :param y_max: float
    The maximum value along the y-axis that bounds the final 2D mesh area.
    :param resolution: float
    Resolution of the final 2D mesh.
    :param z_step: float
    The point of intersection of the plane and the z-axis.
    :return: x, y, triangles - array_like, cutplane - vedo.Mesh object
    Returns the mesh as an object, as well as three arrays - coordinates of points on the plane (x, y),
    as well as their connections (triangles).
    """

    shift_x, shift_y, shift_z = shift
    msh = vd.Mesh(path)
    msh.shift(dx=shift_x, dy=shift_y, dz=shift_z)
    msh.scale(scale, origin=False)

    msh = msh.shift(dz=-z_step)

    plane = vd.Grid(pos=[x_min, x_max, y_min, y_max], res=(resolution, resolution)).wireframe(False)
    cutplane = plane.clone()
    cutplane.cut_with_mesh(msh)
    cutplane.triangulate()

    points = cutplane.vertices
    triangles = cutplane.cells
    x, y = points[:, 0], points[:, 1]

    return x, y, triangles, cutplane


def volume_mesh(path, side=0.02, gap=None):
    """
    Function defining a tetrahedron unstructured volumetric mesh limited by the geometry of the stl file.
    :param path: string
    The path to the stl file.
    :param side: float
    Desired side of the single tetras as fraction of the bounding box diagonal.
    :param gap: float
    Keep this minimum distance from the surface, if None an automatic choice is made.
    :return: array_like
    Returns the mesh as two arrays - coordinates of points on the plane (vertices),
    as well as their connections (faces).
    """

    surf = vd.Mesh(path)
    volume_mesh = surf.tetralize(side=side, gap=gap)
    faces = volume_mesh.cells
    vertices = volume_mesh.vertices

    return vertices, faces


def capacity(phi, dphi, area):
    """
    Function for calculating electrical capacity.
    :param phi: array_like
    Function value on the boundary elements.
    :param dphi: array_like
    Function normal derivative value on the boundary elements.
    :param area: array_like
    Boundary element area.
    :return: float
    The value of electrical capacity.
    """
    return np.sum(area * phi * dphi)


def artifact_correction(mesh, bem_sol, bc, smooth_order=8, number_of_layers=4, threshold=4.5):
    """
    A function that corrects artifacts that occur near the boundary
    of the computational domain of solutions using the boundary element method.
    :param mesh: vedo.Mesh object
    An object that defines the grid on which artifacts need to be corrected.
    :param bem_sol: array_like
    Solution with artifacts, which is automatically generated by the solver.
    :param bc: float
    The number that specifies the boundary condition.
    :param smooth_order: int
    The order of smoothing of the solution at the boundary, which is given by averaging over neighboring points.
    :param number_of_layers: int
    The number of layers of points adjacent to the boundary, on which we will eliminate artifacts.
    :param threshold: float
    The value that determines outliers using a modified z-score.
    :return: array_like
    Solution array with adjusted values.
    """

    boundary_indices = mesh.boundaries(return_point_ids=True)
    bem_sol[boundary_indices] = bc

    x = mesh.vertices[:, 0]
    y = mesh.vertices[:, 1]
    z = mesh.vertices[:, 2]

    # Getting the points from boundary and near the boundary
    points_set = set()

    for i in range(boundary_indices.shape[0]):
        cp = mesh.connected_vertices(boundary_indices[i])
        for cp_ind in cp:
            if bem_sol[cp_ind] != 140:
                points_set.add(cp_ind)

    for _ in range(number_of_layers - 1):

        points = np.array(list(points_set))

        for i in range(points.shape[0]):
            cp = mesh.connected_vertices(points[i])
            for cp_ind in cp:
                if bem_sol[cp_ind] != 140:
                    points_set.add(cp_ind)

    points = np.array(list(points_set))

    # Find the outliers
    bad_points = []
    good_points = []

    median = np.median(bem_sol[points])
    z_score = 0.6745 * np.absolute(bem_sol[points] - median) / np.median(np.absolute(bem_sol[points] - median))
    for i in range(points.shape[0]):
        if z_score[i] > threshold:
            bad_points.append(points[i])
        else:
            good_points.append(points[i])

    bad_points = np.array(bad_points)
    good_points = np.array(good_points)

    # Smoothing and the rough interpolation
    for i in range(bad_points.shape[0]):
        cp_tobad = mesh.connected_vertices(bad_points[i])
        good_indices = []
        for ind in cp_tobad:
            if not (ind in bad_points):
                good_indices.append(ind)
        distances = (x[good_indices] - x[bad_points[i]]) ** 2 + (y[good_indices] - y[bad_points[i]]) ** 2 + (z[good_indices] - z[bad_points[i]]) ** 2
        weights = np.exp(-distances)
        weights = weights / np.sum(weights)
        bem_sol[bad_points[i]] = np.sum(bem_sol[good_indices] * weights)

    for _ in range(smooth_order):
        for i in range(points.shape[0]):
            cp = mesh.connected_vertices(points[i])
            distances = (x[cp] - x[points[i]]) ** 2 + (y[cp] - y[points[i]]) ** 2 + (z[cp] - z[points[i]]) ** 2
            weights = np.exp(-distances)
            weights = weights / np.sum(weights)
            bem_sol[points[i]] = np.sum(bem_sol[cp] * weights)

    return bem_sol


def min_area(x, y, bem_sol):
    """
    A function that determines the area adjacent to the minimum value.
    :param x: array_like
    x - coordinates of mesh.
    :param y: array_like
    y - coordinates of mesh.
    :param bem_sol: array_like
    Solution on the mesh obtained by boundary element method.
    :return: min_val - float, (x_min_area, y_min_area) - array_like
    Returns the minimum value of the solution, as well as the area adjacent to this value.
    """
    min_val = np.min(bem_sol)
    x_min_area = x[(bem_sol > min_val) & (bem_sol < 1.05 * min_val)]
    y_min_area = y[(bem_sol > min_val) & (bem_sol < 1.05 * min_val)]
    return min_val, x_min_area, y_min_area
